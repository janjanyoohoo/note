# Java设计模式

## 概念

设计模式原则,其实是指程序员在编程时,应当遵守的原则. 也是各种设计模式的基础;

- 七大原则
  - 单一职责
  - 开放封闭
  - 里式替换
  - 依赖倒置
  - 接口隔离
  - 迪米特
  - 合成复用

```txt
编写软件过程中，程序员面临着来自耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性等多方面的 挑战，设计模式是为了让程序(软件)，具有更好的
1) 代码重用性 (即：相同功能的代码，不用多次编写) 
2) 可读性 (即：编程规范性, 便于其他程序员的阅读和理解)
3) 可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护) 
4) 可靠性 (即：当我们增加新的功能后，对原来的功能没有影响) 
5) 使程序呈现高内聚，低耦合的特性 
```

### 单一职责

`一个类只应当只负责一项职责`

- 对一个类来说,一个类应当只负责一项职责;
  - 如果一个类具有两个功能A,B; 当A功能需要改变类时,可能导致功能2受到影响;所以应当将类的粒度分为A,B两个类

一个类只负责一种事情(粒度); 负责交通工具的类,是否应当区分负责骑车,自行车的类的职责;

当一个类的方法较少时,特殊情况下可以将类级别的单一职责下沉到方法级别实现单一职责;

#### 单一职责原则注意事项和细节 

1) 降低类的复杂度，一个类只负责一项职责。 

2) 提高类的可读性，可维护性 

3) 降低变更引起的风险 

4) 通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中
方法数量足够少，可以在方法级别保持单一职责原则

### 接口隔离

`客户端不应该依赖他不需要的接口,即一个类对另一个类的依赖应该建立在最下级的接口上`

将一个接口拆分为具体的多个接口,再定义一个子接口继承全部接口,类只需根据自己需要的方法依赖对应的接口即可;

![image-20210530223317868](https://jianjiandawang.oss-cn-shanghai.aliyuncs.com/Typora/20210530223317.png)

- 示例

此时,类AAA或类BBB通过接口A依赖了AA或BB,

但是AAA或BBB只需要接口A的一个方法, 而他们所依赖的实现类AA或BB则必须要重写全部方法

这种情况又被接口隔离原则,应当拆分为两个接口Aa/Ab ,而AAA/BBB依赖实现拆分后接口的实现类,则可以避免依赖A接口的全部方法;

拆分后的Aa&Ab 只包含了A的部分方法,此时可以定义第三个接口Ac ,此接口继承AaAb即可拥有原接口A的全部方法,又实现了接口隔离原则

```java
// 接口A
interface A{
    function1();
    function2();
}

//实现类AA 
class AA implement A{
    function1(){
        ...
    }
    function2(){
        ...
    }
}
//实现类BB
class BB implement A{
    function1(){
        ...
    }
    function2(){
        ...
    }
}
//类AAA
class AAA{
    fun(A a){
        a.function1();
    }
}
//类BBB
class AAA{
    fun(A a){
        a.function2();
    }
}
/*************************实现接口隔离原则************************************/
// 接口A1
interface A1{
    function();
}
//接口A2
interface A2{
    function();
}
//实现类A1impl
class A1impl implement A1{
     function(){
         ...
     }
}
//实现类A2impl
class A2impl implement A2{
         function(){
         ...
     }
}
//类C1
class C1{
    fun(A1 a){
        a.function();
    }
}
//类C2
class C2{
    fun(A2 a){
        a.function();
    }
}
```

### 依赖倒置

依赖倒置原则(Dependence Inversion Principle)是指：

- 1) 高层模块不应该依赖低层模块，二者都应该依赖其抽象 

- 2) 抽象不应该依赖细节，细节应该依赖抽象 

- 3) 依赖倒转(倒置)的中心思想是面向接口编程
- 4) 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架 构比以细节为基础的架构要稳定的多。在 java 中，抽象指的是接口或抽象类，细节就是具体的实现类
- 5) 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完
  成

依赖倒置的核心是面向接口编程,依赖抽象;

依赖关系的三种传递方式:

1. 构造方法传递(成员变量定义为接口)
2. Set方法传递(成员变量定义为接口)
3. 通过接口传递(方法参数接收接口)

```java
//接口
interface Ainterface{
    void function();
}
//通过接口传递
class Alass{
    public void fun(Ainterface ai){
        ai.function();
    }
}
//通过构造方法依赖
class Alass{
    public Alass(Ainterface ai){
        ai.function();
    }
}
//通过SET方法依赖
class Alass{
    private Ainterface ai;
    public void setAi(Ainterface ai){
        this.ai = ai;
    }
}
```

依赖倒置原则和注意事项

1. 低层模块尽量都要有抽象类和接口,或者两者都有,稳定性更好;
2. 变量的声明类型尽量是抽象类或接口,这样我们的变量引用和实际对象之间有一层缓冲层,有利于程序的扩展和优化;
3. 继承时,遵循里式替换原则;

### 里式替换原则

OO中的继承性的思考和说明

1) 继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契 约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实 现的方法任意修改，就会对整个继承体系造成破坏。
2) 继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵 入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他的类所继承， 则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子 类的功能都有可能产生故障
3) 问题提出：在编程中，如何正确的使用继承? => **里氏替换原则**

- 在任何使用父类的地方,能够透明的使用子类
- 遵循里氏替换原则，在子类中尽量不要重写父类的方法
- 继承实际上让两个类耦合性增强了，在适当的情况下，可 以通过聚合，组合，依赖来解决问题。
  - 组合/聚合->在A类中定义B类对象与所需要的方法,通过B对象调用方法

```java
// 原结构 A <- B 当B重写A中方法时不符合里式替换, 改用以下方式,通过定义一个共同的基类Base,然后使用聚合/组合来实现B中可以调用A的方法
//基类
class Base{
    
}

//A类
class A extent Base{
    void fun1(){
        
    }
}
//B类
class B extent Base{
    private A a = new A();
    void fun2(){
        
    }
    //组合
    void fun1(){
        a.func1();
    }
}
```

### 开闭原则

`面对扩展开放,面对修改关闭,通过抽象实现扩展的便捷,并且不影响已存在的实现的功能`

1) 开闭原则（Open Closed Principle）是编程中最基础、最重要的设计原则 

2) 一个软件实体如类，模块和函数应该对扩展开放(对提供方)，对修改关闭(对使用 方)。用抽象构建框架，用实现扩展细节。

3) 当软件需要变化时，尽量**通过扩展软件实体的行为来实现变化，而不是通过修改已 有的代码来实现变化。**

4) 编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。

面向提供方的扩展开放,面向使用方的修改关闭;

- 定义一个抽象的接口,一个抽象的方法
- 定义不同的实现类实现方法不同的逻辑,可以轻松达到开闭原则
- 如果将多个方法实现放在一个具体的类中,当扩展时,就会面临问题;

思路：把创建Shape类做成抽象类，并提供一个抽象的draw方法，让子类去实现即可， 这样我们有新的图形种类时，只需要让新的图形类继承Shape，并实现draw方法即可，
使用方的代码就不需要修 -> 满足了开闭原则

### 迪米特法则

基本介绍 

1) 一个对象应该对其他对象保持最少的了解 

2) 类与类关系越密切，耦合度越大 

3) 迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的 越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内 部。对外除了提供的public 方法，不对外泄露任何信息 

4) 迪米特法则还有个更简单的定义：只与直接的朋友通信
5) 直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系， 我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合 等。

其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而 出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。

迪米特法则注意事项和细节 

- 迪米特法则的核心是降低类之间的耦合 

- 但是注意：由于每个类都减少了不必要的依赖，因此**迪米特法则只是要求降低类间(对象间)耦合关系，并不是要求完全没有依赖关系**

### 合成复用原则

原则是尽量使用合成/聚合的方式，而不是使用继承

![image-20210603231236842](https://jianjiandawang.oss-cn-shanghai.aliyuncs.com/Typora/20210603231244.png)

- 当B需要使用A的方法,但是非必要使用继承时,可以通过依赖/聚合/组合的方式
  - 依赖,通过在B中定义方法,入参接收A类,并用A类对象调用对应方法
  - 聚合,在B中定义A类变量,通过set方法设置A类变量的值,然后使用对象调用方法
  - 组合,在B中定义A变量并直接实例化,然后通过对象调用方法

### 总结

`实现松耦合`

 设计原则核心思想 

-  找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代 码混在一起。
- 针对接口编程，而不是针对实现编程。
- **为了交互对象之间的松耦合设计而努力**



# 设计模式

设计模式分为三种类型，共23种

1. 创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式。
2. 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享 元模式、代理模式。
3. 行为型模式：模版方法模式、命令模式、访问者模式、迭代器模式、观察者 模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式(责任链模式)。

## 迭代器Iterator模式

> 迭代器模式用于在数据集合中遍历集合
>
> 将遍历的功能置于具体的数据集合之外,不论数据集合的实现如何变化都可以使用Iterator

### UML

<img src="https://jianjiandawang.oss-cn-shanghai.aliyuncs.com/Typora/20210626162846.png" alt="image-20210626162839699" style="zoom:150%;" />	

### 注意事项

- ConcreteIterator 只针对具体的一个数据集合实现其相关的迭代器
- 如果需要不同的迭代方式则ConcreteAggregate 需要多个不同的ConcreteIterator 
- *Aggregate* ->创建 *Iterator* 

### 设计模式角色

- Iterator 迭代器接口
  - 包含*hasNext*() 与 *next*() 
- ConcreteIterator 具体的迭代器
  - 实现迭代器接口,重写hasNext() 与 next() 方法
- Aggregate 数据集合接口
  - 包含*iterator*() 方法 返回一个Iterator的实现
- ConcreteAggregate 具体的数据集合
  - 实现数据集合接口,实现iterator() 方法

### 拓展

- next()返回的是当前元素
- hasNext是确认接下来可以调用next方法
- 将遍历功能置于Aggregate 角色之外
- Aggregate 与Iterator 是相对应的

> com.jianjian.janjan.starter.design.iterator

## 适配器Adapter模式

也被称之为**<u>包装器Wrapper模式</u>**

> 在需要做适当转换后才能使用的情况下,用于填补现有程序与所需程序之间差异的设计模式.

- 类适配器 (使用继承的适配器)  
  - Adapter通过继承/实现 Target与Adaptee 来进行方法适配
- 对象适配器 (使用委托的适配器)
  - Adapter继承Target ,Adapter将Adaptee实现聚合到内部,委托Adaptee对象调用方法进行适配.

> 接口在1.8支持默认方法,同样可以支持适配器模式

### UML

- 类适配器 (继承)

  ![image-20210626170116328](https://jianjiandawang.oss-cn-shanghai.aliyuncs.com/Typora/20210626170116.png)	

- 对象适配器 (聚合)

  ![image-20210626170233562](https://jianjiandawang.oss-cn-shanghai.aliyuncs.com/Typora/20210626170233.png)	

### 注意事项

- 继承通过实现与继承Target与Adaptee实现适配
- 委托通过实现Target 聚合Adaptee来实现适配

### 设计模式角色

- *Target* (对象) 
  - 定义所需要的抽象方法, 即需与Adaptee的方法
- Adapter (适配器)
  - 继承/实现 Target与Adaptee, 并实现Target方法适配调用Adaptee中的实现
- Adaptee (被适配)
  - 已有的实现,其中方法被Adapter继承,并适配被Target中方法调用
- Client (调用者)
  - 调用Target方法.

### 拓展

- Adapter对现有类进行适配生成新的类,提高类的复用性

- Adapter在完全不改变现有代码的前提下使现有代码适配于新的接口
- 当Target与Adaptee是功能完全不同的类时,Adapter模式是无法使用的

> com.jianjian.janjan.starter.design.adapter

## 模板方法TemplateMethod模式



> 是带有模板功能的模式,组成模板的抽象方法被定义在父类中. 在父类中无法知道方法是如何实现的,只能确定方法是如何调用的.子类实现抽象方法决定具体的处理.不同的子类实现处理不同,那么模板方法调用时的行为也会不同.
>
> 在父类中定义处理的流程框架,在子类中实现具体的处理模式.

### UML

![image-20210626174226680](https://jianjiandawang.oss-cn-shanghai.aliyuncs.com/Typora/20210626174226.png)	

### 注意事项

- 父类中定义调用流程逻辑,子类调用方法的具体实现
  - method1() ->待实现模板方法
  - templateMethod() -> 已实现的调用逻辑方法,其中定义了如何调用method

- 不论子类如何实现,都会按照父类的逻辑进行调用
- 父类的模板方法可以用final修饰防止被子类重写
- 抽象方法权限修饰符,应当限制方法被外部直接调用

### 设计模式角色

- AbstractClass (抽象类)
  - 负责实现模板方法, 并定义模板方法中使用到的抽象方法,这些方法由子类实现
- ConcreteClass (实现类)
  - 实现模板使用到的抽象方法,会被AbstractClass 的模板方法调用

### 拓展

- 优点在于父类中编写了算法,子类无需多次实现.
- 父类和子类是紧密联系共同工作的.因此父类中定义的抽象方法,子类必须明确了解这些方法的调用时机.
- 满足里式替换原则,父类中无论保存那个实现类都可以正常工作.

> 抽象阶段确定处理流程是非常重要的
>
> 如何换分处理的级别,哪些处理需要由父类完成,哪些处理需要交给子类负责.并没有明确的规定,可以在开发时灵活设定.

> com.jianjian.janjan.starter.design.template

## 工厂方法FactoryMethod模式

> 使用模板方法模式来构建生成工厂实例,这就是工厂方法模式 父类决定实例的生成方式,但并不决定所要生成的具体的类
>
> 父类中通过模板方法生成实例,实现类实现具体的生成实例的方法.

### UML

![image-20210626184224515](https://jianjiandawang.oss-cn-shanghai.aliyuncs.com/Typora/20210626184224.png)	

### 注意事项

- 产品的构造方法需要时private的,构建产品的方法需要是受保护的.
- 工厂方法需要时final的
- create()方式是模板方法. factoryMethod是工厂方法
  - 工厂方法未规定只有一个,可以是模板方法模式的多个方法,按照一定的流程执行后返回生成的实例对象.
- 不通过new来创建对象,而是调用专用方法来生成实例. 这样就可以防止父类与其他具体类耦合.
- 产品中定义产品需要被使用的方法
- 工厂中定义创建产品的方法

### 设计模式角色

- Product (产品)
- ConcreteProduct (具体的产品)
- Creator (创建者)
  - 依赖模板方法,进行产品的创建.
  - 指定抽象方法由子类实现生成具体的产品
- ConcreteCreator (具体的创建者)
  - 仅实现工厂方法,不实现模板方法.

### 拓展

- 框架与具体加工分工
- 生成实例的三种方式
  - 指定为抽象方法, 子类必须实现该方法.
  - 指定为默认方法,若子类不实现则使用默认行为.
  - 在方法中抛出异常,使子类必须要重写.不重写在运行时就会抛出异常.
- 使用设计模式时应该详细的注释设计模式的名称和使用意图.

> com.jianjian.janjan.starter.design.factoryMethod











## 单例Singleton模式

> 所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类 只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法(静态方法)。

### 注意事项

- 构造函数是private的,禁止从类外部直接调用构造函数

### 设计模式角色

- Singleton
  - 单例模式中仅有这一个角色
  - 角色中有一个返回唯一实例的static方法

### 拓展

- 为什么必须限制?
  - 多个实例可能相互影响产生bug时
  - 单个对象重量级,对于性能开销大时
- 何时生成实例
  - 在第一次调用getInstance()方法时,Singleton类被初始化,singleton字段被初始化

### 单例模式有八种方式：

- <u>饿汉式(静态常量)</u>
  - 优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同 步问题。
  - 缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费
  - 这种单例模式可用，可能造成内存浪费
- <u>饿汉式（静态代码块）</u>
  - 将类实例化的过程放在了静态代码块 中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优 缺点和上面是一样的。
  - 这种单例模式可用，但是可能造成内存浪费
- <u>懒汉式(线程不安全)</u>
  - 线程不安全
- <u>懒汉式(线程安全，同步方法)</u>
  - 性能差
- <u>懒汉式(线程安全，同步代码块)</u> 
  - 性能差
  - 这种同步并不能起到线程同步的作用
- **双重检查**
  - 双重锁校验配合volatile实现
- **静态内部类**
  - 利用内部类的懒加载特性
- **枚举**
  - 枚举的天然单例性,在枚举的构造方法中进行单例对象的初始化.

> com.jianjian.janjan.starter.design.singleton 

## 工厂模式

