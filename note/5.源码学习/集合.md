# HashMap

## 基础属性

### 存储数据结构分析

- hashMap的节点使用链表或数字（有些实现使用二次哈希）， 是**为了解决哈希冲突**（不同的的Key哈希到相同的位置了）。
- **B+树是能够批量、快速的从磁盘加载大量数据，而且可以按需只加载部分数据，适合数据库。**
- **B+树块内是有序的，用二分查找。如果只是顺序查找，是无法做索引的。**
- **在数据都加载到内存的情况下，B+树的查找次数比二叉树多，效率略低。但是二叉树不适合批量从磁盘加载。**
- **hashMap的元素是动态修改的，红黑树修改元素，不用移动元素的位置，因为直接修改左右父指针的值就好了，**
- B+树的同一个块内的元素，没有指针这个东西，所以修改元素就需要移动元素，这个开销就很大了，也会触发频繁内存分配和回收。
- B+树之所以运用于磁盘存储结构，因为磁盘的数据一般都是比较冷的数据，否则一般都会因为淘汰策略常驻内存。
- **热数据用红黑树组织，冷数据用B+树组织。**红黑树相对于B+树就好比链表相对于数组。

### 默认常量

​	`DEFAULT_INITIAL_CAPACITY` 默认缺省值, 不指定table长度时,默认为 1<< 4 长度16, 每次扩容右移一位  长度固定2的次方

​	`MAXIMUM_CAPACITY` 默认缺省table最大长度  1<< 30位 2的30次方

​	`DEFAULT_LOAD_FACTOR`默认的缺省扩容因子0.75,table的size达到length的75%时会除法table的扩容

​	`TREEIFY_THRESHOLD` 树化阈值,默认链表转换为红黑树结构的前置阈值, table的查询时间默认是 O(1) 形成链表后的时间复杂度为O(n)

鉴于; 当table长度超过64, 且有链表长度超过8是,会将链表转换为红黑树, 时间复杂度为O log(n); 之所以长度达到8才进行树化,是因为树的时间复杂度决定的,在8个节点以内,链表的性能更好, 8个节点是链表性能与红黑树性能的分水岭;8个节点以后,红黑树性能更好;

​	`UNTREEIFY_THRESHOLD` 树降级为链表的阈值,当tree节点树小于等于6个会降级为链表,  7是一个避免频繁进行转换的缓冲值; 

​	`MIN_TREEIFY_CAPACITY` 升级为红黑树的前提参数,table长度必须达到64才会进行部分链表的树化,否则,及时链表长度超过8也不会进行树化;

### 属性

​		`Node<K,V>[] table` 	散列表 哈希表,是使用Node数组构建;

- 初始化 : 

  `size` 	当前table的元素个数

  `modCount`		当前table结构修改的次数 (插入,删除) +1;  替换修改不会计数;

  `loadFactor `    	扩容阈值 默认0.75;  当前table中元素的个数,超过这个阈值之后会进行扩容; 此处的个数为已存储的全部元素个数,即为是所有链表的长度; 若不进行扩容,则会导致时间复杂度由O(1) 变为O(n) 使hash表的性能严重下降;

  `threshold`		负载因子; 负载因子 = loadFactory * capacity ;  数组长度*加载因子 =负载因子; 负载因子就是当前table需要进行扩容的size;

  

## Node<K,V>

​	

## 路由寻址算法

### 哈希扰动

​		hash() 方法  方法通过扰动运算,使key的hashCode的**高16位也可以参与运算**( hashCode() >> 16 右移16位) 计算得出hash扰动后的hash值

​		**hash扰动让高16位参与运算的原因是table初始时length一般较小; 为了让高16位也可以参与到运算中,并且可以减少hash碰撞的概率;**

让高位参加运算后再 & length-1 可以让index的散列更加均匀;如果两个数的高位不参与运算, 低位运算相同的概率很大,容易产生hash碰撞; 

​	最终hash地址为 **hash() & capacity -1** 

## hash()

key的hash值

```java
    static final int hash(Object key) {
        int h;
		//高16位参与运算,减少hash碰撞,使元素存储在hash表中更均匀
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
```

## tableSizeFor() 

哈希表大小, 2次幂

```java
 static final int tableSizeFor(int cap) {
     //当前length-1 主要为了处理临界值的存储位置可以在当前表存的下
        int n = cap - 1;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
     //一共 |=运算5次, 无符号左移13位; 最终结果是当前cap - 1的最大位到最小位全为1,比cap最近的2次幂的值小1;
     //如果n<0则size为1, 如果大于最大值则为max, 否则结果+1;正好为二进制
        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }
```

```java
	// 16  14
	// 0001 0000
	// 0000 1110
---------------------
    // 0000 1110 >>> 1
    // 0000 0111 = 0000 1111 >>> 2
    // .....>>> 16 0000 1111 = 15 + 1 =16
```

## getKey()

```java
public V get(Object key) {
        Node<K,V> e;
    	//调用hash计算key的hash, 通过getNode找key
        return (e = getNode(hash(key), key)) == null ? null : e.value;
    }
```

## getNode()

```java
 final Node<K,V> getNode(int hash, Object key) {
     	//定义变量
        Node<K,V>[] tab; Node<K,V> first, e; int n; K k;
     	//tab=当前表  n=当前length first当前需要被查找的key所在的头结点  
        if ((tab = table) != null && (n = tab.length) > 0 &&(first = tab[(n - 1) & hash]) != null) {
            //如果头节点哈希与参数hash相同,则对比二者key是否完全相同;
            if (first.hash == hash && // always check first node
                ((k = first.key) == key || (key != null && key.equals(k))))
                //相同则返回当前节点
                return first;
            //不满足头结点相同, 遍历链表或者tree 查找hash相同的key 然后对比key是否相同
            if ((e = first.next) != null) {
                if (first instanceof TreeNode)
                    //tree
                    return ((TreeNode<K,V>)first).getTreeNode(hash, key);
                do {
                    //链表
                    if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        return e;
                    //没有下一个节点 遍历结束
                } while ((e = e.next) != null);
            }
        }
     	//没有查找到符合条件的 返回null
        return null;
    }
```

## containskey()

```java
    public boolean containsKey(Object key) {
        return getNode(hash(key), key) != null;   //同样调用getNode方法, 返回null 即说明不存在;
    }
```

## put()

```java
  public V put(K key, V value) {
      	//主要调用putVal() 为其提前计算好key的hash()
        return putVal(hash(key), key, value, false, true); 
    }
```

## putVal()

JDK 1.7 链表从头插入;  1.8从尾插入

```java
  final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) {
      	//定义变量
        Node<K,V>[] tab; Node<K,V> p; int n, i;
      	//分支 1 	tab,n进行了赋值 为当前table和table.length
        if ((tab = table) == null || (n = tab.length) == 0)
            //初始化一次 进行扩容 会扩容为默认值 capacity 16 : threshold 12
            n = (tab = resize()).length;
      	//分支 2  p,i进行赋值 
      	//伪代码 index=(参数hash & length-1)  p=table[index] i=index 
        if ((p = tab[i = (n - 1) & hash]) == null)
            //如果当前索引处没有元素,直接添加一个新的Node对象即可
            tab[i] = newNode(hash, key, value, null);
      	//分支 3 
        else {
            // 定义变量 
            Node<K,V> e; K k;
            // 分支3.1 如果当前元素p(在分支2赋值的)的hash与参数hash相同,且p.key也与参数key相同
            if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k))))
                e = p; //当前e 赋值为当前元素 p
            // 分支3.2 如果p是红黑树,执行红黑树逻辑
            else if (p instanceof TreeNode)
                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
            // 分支3.3 不是树节点 key也不相同;
            else {
                //遍历当前p元素的这条链表 binCount用来统计链表长度,作为转换红黑树的判断条件
                for (int binCount = 0; ; ++binCount) {
                    //分支3.3.1 e在此赋值p.next
                    if ((e = p.next) == null) {
                        //如果p.next节点为null,则直接放入一个新Node即可
                        p.next = newNode(hash, key, value, null);
                        //放入后会判断 当前链表长度时候达到9个 满足链表转换为红黑树的条件,
                        if (binCount >= TREEIFY_THRESHOLD - 1)//-1 for 1st减一是因为循环是从p节点的下一个节点开始的
                            //调用转换方法,是否转换还需要再次方法内判断,如果table的size不足64 也不会转换;
                            treeifyBin(tab, hash);
                        //存放完成结束此次循环 
                        break;
                    }
                    //分支3.3.2 如果此次循环的e节点 hash key 都与参数相同; 即结束循环,后面执行更新value操作
                    if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k))))
                        break;
                    p = e; //p为当前遍历的最后一个节点e; 两种情况 1. null说明是新增值, 2 !=null 说明需要更新value
                }
            }
            //更新值
            if (e != null) { // existing mapping for key
                V oldValue = e.value;   //当前e的value赋值给oldValue
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;   //更新e为参数传入的value
                afterNodeAccess(e);
                return oldValue;  //更新值不计算修改map的次数,返回被替换的值
            }
        }
        ++modCount; //map修改次数+1
        if (++size > threshold) //是否需要金西行扩容
            resize();
        afterNodeInsertion(evict);
        return null;	//新插入数据返回null
    }
```

## reSize()

```java
/**
	官方注释:(百度翻译)
	初始化或加倍表大小。
	如果为空，则根据字段阈值中保留的初始容量目标进行分配。
	否则，因为我们使用的是二次幂展开，所以每个bin中的元素要么留在同一索引中，要么在新表中以二次幂偏移量移动。
 */
final Node<K,V>[] resize() {
    //------------------变量初始化------------------
    	//当前哈希表 赋值-> oldTab
        Node<K,V>[] oldTab = table;
    	//oldCap旧哈希表长度 -> oldTab为null->0 否则 ->oldTab.length;
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
    	//oldThr旧哈希表的扩容阈值 -> 当前threshold扩容的数量阈值
        int oldThr = threshold;
    	//新的 capacity容量 threshold扩容阈值 -> 初始化定义
        int newCap, newThr = 0;
    //------------------判断逻辑1------------------
    	// 分支1 
    	// oldCap 大于 0
        if (oldCap > 0) {
            
            //分支 1.1
            // 如果旧Cap > 0 &&  旧Cap>= capacity最大值 ; threshold扩容阈值等于Integer的最大值, 旧表不进行扩容直接返回
            // 并且将thrshold 置于Integer的最大值, 基本不会再达到扩容条件;
            if (oldCap >= MAXIMUM_CAPACITY) {
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            //分支 1.2
            // 否则 newCap的值为oldCap<<1 扩大一倍 后 小于 MAXIMUM_CAPACITY最大值
            // 并且 oldCap >= DEFAULT_INITIAL_CAPACITY 默认capacity的大小16 ,如果oldCap小于16 则不满足条件
            // ?问题: 如果 oldCap<最大值MAXIMUM_CAPACITY  但是 不大于等于 默认值16: 那么 newThr仍旧为0,但是newCap等于oldCap*2;
            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY)
              	// 满足条件则newThr << 1  扩容阈值 增加一倍              
                newThr = oldThr << 1; // double threshold
        }
    
    
    	//分支2
    	// oldCap 不大于 0  但是 oldThr > 0 
        else if (oldThr > 0) // initial ceipacity was placed in threshold 初始容量设置为阈值
            //将capacity 初始化为 threshold大小; 例初始化时指定为0   那么threshold会为2 capacity为0
            newCap = oldThr;
    
    	//分支3
    	// oldCap 不大于 0  且 oldThr 也不大于 0 
        else {               // zero initial threshold signifies using defaults 零初始阈值表示使用默认值
            // 将会进行初始化, 初始化大小为默认值大小 newCap -> 16 ; newThr-> 16*0.75=12;
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
    
    //------------------判断逻辑2------------------
    	//分支4 
    	//扩容阈值为0  -> 分支1.2可能出现newThr == 0 的情况 
        if (newThr == 0) {
            // capacity * loadFactor = threshold; 计算期望的newThr值
            float ft = (float)newCap * loadFactor;
            // newThr==0 newCap>0情况下 执行初始化逻辑
            // 如果newCap达到capacity最大值, 则赋值newThr为Integer最大值, 之后很难再达到扩容阈值触发扩容
            // 否则赋值newThr=ft 刚计算得出的值;
            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
    	// 真正修改类变量threshold扩容阈值的值 = newThr变量;
        threshold = newThr;
    	//------------------以上逻辑计算出新的capacity,threshold------------------
    
    	// 执行哈希表扩容排列
        @SuppressWarnings({"rawtypes","unchecked"})
    	//定义一个新的 哈希表,大小为 newCap
        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
    	//赋值 当前类属性哈希表 = 新定义哈希表
        table = newTab;
    	//重新排序逻辑 oldTab不为null的情况下进行   oldTab在方法第一行定义
        if (oldTab != null) {
            //遍历旧哈希表 嵌套do...while循环每次遍历一条链表
            for (int j = 0; j < oldCap; ++j) {
                // 定义一个Node变量e用来存储 当前遍历的节点
                Node<K,V> e;
                //分支A 当前节点 不为null  进行e的赋值 进入逻辑
                if ((e = oldTab[j]) != null) {
                    // e已经赋值,置空旧哈希表当前节点
                    oldTab[j] = null;
                    // 分支A.1
                    //如果 e 的next为null,则没有链表, 直接进行hash计算出新表位置存储即可
                    if (e.next == null)
                        //当前节点的hash值 & 新表长度-1 是e在新表中的下标; 赋值即可
                        newTab[e.hash & (newCap - 1)] = e;
                    // 分支 A.2  当前节点是树节点  执行红黑树的逻辑
                    else if (e instanceof TreeNode)
                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                    // 分支 A.3 当前节点是链表结构 进行元素位置重新hash
                    else { // preserve order
                        /**哈希表扩容,每个链表中的元素扩容后只会存在两种位置情况 
                         * 例如:旧哈希表长度16,当前链表头结点的旧index = 15; 扩容后两种可能:(伪代码)
                         * 1. hash & newCap-1 = index = 15
                         * 2. hash & newCap-1 = index = 31  (是旧index+扩容的长度)
                         * 主要原因: 
                         *	计算节点在哈希表中的下标 使用的方法是(伪代码) 当前元素hash & 当前哈希表.length-1 = index
                         *  当前元素hash = 1100 0101
                         *	旧数组长度-1 = 0000 1111 = 15
                         *	二者&运算结果 = 0000 0101 = 5 其在旧哈希表中下标则为5
                         *
                         *	扩容后的第一种情况
                         *	当前元素hash = 1100 0101
                         *	新数组长度-1 = 0001 1111 = 31
                         *	二者&运算结果 = 0000 0101 = 5 其在新哈希表中下标依旧为5
                         *
                         *  另一种情况 
                         *	当前元素hash = 1101 0101
                         *	数组长度-1 =   0001 1111 = 31
                         *	二者&运算结果 = 0001 0101 = 21 那么此元素在扩容后的新下标则为 21 
                         *  可以发现二者在16位的哈希表中 只能获取四位有效数字时,发生哈希冲突,在同一个index位置中
                         *	而扩容后, 有效位置为5位,实际只多了一种情况 就是第5位为1, 那么就是此元素就是存储在高位(新位置);
                         */
                        // 变量定义 低位 头尾节点 ,头节点用于存储到新链表,尾节点用于存储当前元素下次循环使用
                        Node<K,V> loHead = null, loTail = null;
                        // 变量定义 高位 头 尾节点
                        Node<K,V> hiHead = null, hiTail = null;
                        // 当前节点的next节点
                        Node<K,V> next;
                        // 循环链表
                        do {
                            // 先取出e的next节点保存下次循环要用;
                            next = e.next;
                            // 分支 A.3.1 
                            // oldCap必定为2^n, 是个整数 整数的二进制只有一位是1,其余为为0
                            // e.hash为当前元素的hash值 & 2^n 结果只有两种(假定oldCap=16)  0000 0000 / 0001 0000
                            // 0000 0000 = 0 说明当前元素是低位元素; 
                            // 0001 0000!= 0; 高位元素
                            // 因为此处计算未将length-1,所以可以计算到第五位的值,0/1两种情况符合上方注释扩容后的两种情况
                            if ((e.hash & oldCap) == 0) {
                                // 分支 A.3.1.1 
                                // 如果 loTail低位的尾节点为null 说明当前新表的此位置还没有元素,则将低位头节点赋值为e
                                if (loTail == null)
                                    loHead = e;
                                // 分支 A.3.1.2 否则 loTail低位尾节点的写一个节点 赋值为e
                                else
                                    loTail.next = e;
                                //此处为分支 A.3.1的逻辑; 判断完后将低位的尾节点置为当元素e下次循环逻辑走分支A.3.1.2
                                loTail = e;
                            }
                            // 分支A.3.2 不满足(e.hash & oldCap) == 0
                            else {
                                //分支A.3.2.1 高位尾元素为null就放到第一个元素 为头节点
                                if (hiTail == null)
                                    //将e 放到高位头节点
                                    hiHead = e;
                                //分支 A.3.2.2
                                else
                                    //将e 放到高位尾节点
                                    hiTail.next = e;
                                //此处为分支 A.3.2的逻辑; 判断完后将高位的尾节点置为当元素e下次循环逻辑走分支A.3.2.2
                                hiTail = e;
                            }
                        } while ((e = next) != null); //当前元素的下个节点为null 则此条链表的重新摆放完成 开始保存
                        //保存逻辑
                        if (loTail != null) { //低位尾元素为null 说明当前链表没有元素被存储在低位index
                            // 低位尾元素的next置为null
                            loTail.next = null;
                            //存储到 当前循环j 为低位下标;
                            newTab[j] = loHead;
                        }
                        if (hiTail != null) {//高位尾元素为null 说明当前链表没有元素被存储在高位index
                            hiTail.next = null;
                            //高位元素下标 j+oldCap;  oldCap的大小就是扩容增加的大小
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
    	//返回新哈希表
        return newTab;
    }
```



## removeNode()

```java
    final Node<K,V> removeNode(int hash, Object key, Object value,boolean matchValue, boolean movable) {
        Node<K,V>[] tab; Node<K,V> p; int n, index;
        if ((tab = table) != null && (n = tab.length) > 0 &&
            (p = tab[index = (n - 1) & hash]) != null) {
            Node<K,V> node = null, e; K k; V v;
            if (p.hash == hash &&
                ((k = p.key) == key || (key != null && key.equals(k))))
                node = p;
            else if ((e = p.next) != null) {
                if (p instanceof TreeNode)
                    node = ((TreeNode<K,V>)p).getTreeNode(hash, key);
                else {
                    do {
                        if (e.hash == hash &&
                            ((k = e.key) == key ||
                             (key != null && key.equals(k)))) {
                            node = e;
                            break;
                        }
                        p = e;
                    } while ((e = e.next) != null);
                }
            }
            if (node != null && (!matchValue || (v = node.value) == value ||
                                 (value != null && value.equals(v)))) {
                if (node instanceof TreeNode)
                    ((TreeNode<K,V>)node).removeTreeNode(this, tab, movable);
                else if (node == p)
                    tab[index] = node.next;
                else
                    p.next = node.next;
                ++modCount;
                --size;
                afterNodeRemoval(node);
                return node;
            }
        }
        return null;
    }
```

# HashTable

## 构造方法与属性

HashTable使用的hash算法与HashMap不同

其通过**(hash & 0x7FFFFFFF) % Capacity**计算出索引地址,为了均匀hash分布通过质数来降低冲突概率

**hash&0x7FFFFFFF就是保证首位为0而其它位不变**是整型里面的最大值,转换成个二进制

0x7FFFFFFF 0111 1111 1111 1111 1111 1111 1111 1111（前31一个1代表数值，在计算机中整型最高位（32位）是符号位 0代表正数，1代表负数）

**hash与其按位与得到一个正数**

每次扩容的容量为当前**容量的一倍+1 虽然不保证capacity是一个质数，但至少保证它是一个奇数。**

```java
	// 哈希表数据
	private transient Entry<?,?>[] table;
	//当前哈希表元素数
    private transient int count;
	//扩容阈值
    private int threshold;
	//加载因子
    private float loadFactor;
	//修改次数
    private transient int modCount = 0;

	//内部类Entry , 遍历时使用
    private static class Entry<K,V> implements Map.Entry<K,V> {
        final int hash;
        final K key;
        V value;
        Entry<K,V> next;
    }

```



## put

```java
   public synchronized V put(K key, V value) {
        // null 值 抛空指针
        if (value == null) {
            throw new NullPointerException();
        }

        // 计算hash 确定在tale中的index
        Entry<?,?> tab[] = table;
        int hash = key.hashCode();
        int index = (hash & 0x7FFFFFFF) % tab.length;
       
        @SuppressWarnings("unchecked")
        // 获取对应节点的元素
        Entry<K,V> entry = (Entry<K,V>)tab[index];
       	//遍历链表看key是否已存在
        for(; entry != null ; entry = entry.next) {
            //如果当前元素与参数key hash 相同 则更新值 返回被替换的值
            if ((entry.hash == hash) && entry.key.equals(key)) {
                V old = entry.value;
                entry.value = value;
                return old;
            }
        }
		// 不存在key则否则添加新元素
        addEntry(hash, key, value, index);
        return null;
    }
```

## addEntry

```java
private void addEntry(int hash, K key, V value, int index) {
    	// 修改次数
        modCount++;

        Entry<?,?> tab[] = table;
    	// 当前table的元素数量是否达到扩容标准
        if (count >= threshold) {
            // rehash扩容
            rehash();
			// 扩容后重新计算当前元素的hash与index
            tab = table;
            hash = key.hashCode();
            index = (hash & 0x7FFFFFFF) % tab.length;
        }

        // =创建一个新Entry 使用头插法 将元素存入table
        @SuppressWarnings("unchecked")
        Entry<K,V> e = (Entry<K,V>) tab[index];
        tab[index] = new Entry<>(hash, key, value, e);
        count++;
    }
```

## rehash

```java
private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

protected void rehash() {
     	//变量定义
        int oldCapacity = table.length;
        Entry<?,?>[] oldMap = table;

        // 新容量等于old + 1  因为计算index的算法不同 为了是hash分布更均匀 
     	// 虽然不保证capacity是一个质数，但至少保证它是一个奇数。
        int newCapacity = (oldCapacity << 1) + 1;
        if (newCapacity - MAX_ARRAY_SIZE > 0) {
            if (oldCapacity == MAX_ARRAY_SIZE)
                // Keep running with MAX_ARRAY_SIZE buckets
                //当前扩容达到最大值,继续使用旧容量;
                return;
            newCapacity = MAX_ARRAY_SIZE;
        }
    	//使用 扩容后的 capacity 创建一个新hash表
        Entry<?,?>[] newMap = new Entry<?,?>[newCapacity];

        modCount++;
    	//计算新扩容阈值 capacity*loadfactory 与 MAX_ARRAY_SIZE更小的一个
        threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);
    	//赋值为新表
        table = newMap;
		//遍历哈希表
        for (int i = oldCapacity ; i-- > 0 ;) {
            //遍历链表
            for (Entry<K,V> old = (Entry<K,V>)oldMap[i] ; old != null ; ) {
                // 先取出当前元素的next作为下个循环的元素
                Entry<K,V> e = old;
                old = old.next;
				//通过hash算法计算当前元素的新位置
                int index = (e.hash & 0x7FFFFFFF) % newCapacity;
                //使用头插法,hash表中当前索引的值放入到 新数据的next节点
                e.next = (Entry<K,V>)newMap[index];
                //然后将新数据放入hash表中对应位置
                newMap[index] = e;
            }
        }
    }
```

## remove

```java
public synchronized V remove(Object key) {
    	//当前数组
        Entry<?,?> tab[] = table;
    	//计算参数key的hash
        int hash = key.hashCode();
    	//寻址算法, 计算key在hash表中的位置
        int index = (hash & 0x7FFFFFFF) % tab.length;
        @SuppressWarnings("unchecked")
    	//取出对应索引的头元素
        Entry<K,V> e = (Entry<K,V>)tab[index];
    	//prev为上一个元素, e为当前被遍历的元素
        for(Entry<K,V> prev = null ; e != null ; prev = e, e = e.next) {
            //如果当前元素e与key的hash eques一致 执行删除
            if ((e.hash == hash) && e.key.equals(key)) {
                modCount++;
                //是否有上一个元素,有则用上一个元素关联下一个元素
                if (prev != null) {
                    prev.next = e.next;
                } else {
                    //是头元素,直接将下一个元素赋值在hash表做头元素
                    tab[index] = e.next;
                }
                count--;
                //返回被删除值
                V oldValue = e.value;
                e.value = null;
                return oldValue;
            }
        }
    	//未找到对应key,返回null
        return null;
    }
```

## get

```java
    public synchronized V get(Object key) {
        // 哈希表  路由寻址
        Entry<?,?> tab[] = table;
        int hash = key.hashCode();
        int index = (hash & 0x7FFFFFFF) % tab.length;
        //找到对应索引,遍历链表元素 比对hash与key, 找到则返回,没找到则为null
        for (Entry<?,?> e = tab[index] ; e != null ; e = e.next) {
            if ((e.hash == hash) && e.key.equals(key)) {
                return (V)e.value;
            }
        }
        return null;
    }
```

## contains

```java
    public synchronized boolean contains(Object value) {
        //职为null,抛出空指针
        if (value == null) {
            throw new NullPointerException();
        }
		//啥双层for遍历hash表与链表 equals比对value 有则true,没有则null
        Entry<?,?> tab[] = table;
        for (int i = tab.length ; i-- > 0 ;) {
            for (Entry<?,?> e = tab[i] ; e != null ; e = e.next) {
                if (e.value.equals(value)) {
                    return true;
                }
            }
        }
        return false;
    }
```

## containsKey

```java
    public synchronized boolean containsKey(Object key) {
        // hash寻址,计算下标
        Entry<?,?> tab[] = table;
        int hash = key.hashCode();
        int index = (hash & 0x7FFFFFFF) % tab.length;
        //遍历链表 equals 存在则true 否则 false
        for (Entry<?,?> e = tab[index] ; e != null ; e = e.next) {
            if ((e.hash == hash) && e.key.equals(key)) {
                return true;
            }
        }
        return false;
    }
```



# ArrayList

## 构造方法与属性

```java
// 默认容量	
private static final int DEFAULT_CAPACITY = 10;  
//空数组
private static final Object[] EMPTY_ELEMENTDATA = {};
//默认空数组
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
//当前ArrayList的集合
transient Object[] elementData; // non-private to simplify nested class access
//当前集合的大小
private int size;
//数组最大值为 Integer.MAX-8
private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

```

```java
	//指定初始化大小构造ArrayList, 小于0则报错
    public ArrayList(int initialCapacity) {
        if (initialCapacity > 0) {
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
            this.elementData = EMPTY_ELEMENTDATA;
        } else {
            throw new IllegalArgumentException("Illegal Capacity: "+
                                               initialCapacity);
        }
    }

    //空参构造,通过DEFAULTCAPACITY_EMPTY_ELEMENTDATA 默认空数组初始化ArrayList
     public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }

    // 通过一个Collection集合构架ArrayList
    public ArrayList(Collection<? extends E> c) {
        Object[] a = c.toArray();
        if ((size = a.length) != 0) {
            if (c.getClass() == ArrayList.class) {
                elementData = a;
            } else {
                elementData = Arrays.copyOf(a, size, Object[].class);
            }
        } else {
            // replace with empty array.
            elementData = EMPTY_ELEMENTDATA;
        }
    }
```

## trimToSize

```java
    //去掉集合中为存储数据的索引,通过Arrays.copyOf 赋值一个新数组,用当前集合size大小进行赋值
	public void trimToSize() {
        modCount++;
        if (size < elementData.length) {
            elementData = (size == 0)
              ? EMPTY_ELEMENTDATA
              : Arrays.copyOf(elementData, size);
        }
    }
```

## size  isEmpty  contains

```java
    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size == 0;				//当前size
    }

    public boolean contains(Object o) {
        return indexOf(o) >= 0;			//indexOf不存在则为false
    }
```



## indexOf

```java
    public int indexOf(Object o) {
        if (o == null) {    //为null 则对比null
            for (int i = 0; i < size; i++)
                if (elementData[i]==null)
                    return i;
        } else {			//部位null则equest逐个对比,数组遍历
            for (int i = 0; i < size; i++)
                if (o.equals(elementData[i]))
                    return i;
        }
        return -1; //不存在则返回-1
    }
```

## lastIndexOf

```java
public int lastIndexOf(Object o) {    
    if (o == null) {
        for (int i = size-1; i >= 0; i--)	//从后向前遍历即是最后一次出现的索引
            if (elementData[i]==null)
                return i;
    } else {
        for (int i = size-1; i >= 0; i--)
            if (o.equals(elementData[i]))
                return i;
    }
    return -1;
}
```

## clone

```java
    public Object clone() {
        try {
            ArrayList<?> v = (ArrayList<?>) super.clone();	//调用父类的clone, 返回新集合, 集合修改次数置为0
            v.elementData = Arrays.copyOf(elementData, size);
            v.modCount = 0;
            return v;
        } catch (CloneNotSupportedException e) {
            // this shouldn't happen, since we are Cloneable
            throw new InternalError(e);
        }
    }
```

## toArray

```java
   public Object[] toArray() {
        return Arrays.copyOf(elementData, size);	//通过Arrays方法 copyOf 复制为一个数组即可
    }


    public <T> T[] toArray(T[] a) {				//根据指定类型的数组, 将集合转换为对应类型数组
        if (a.length < size)
            // Make a new array of a's runtime type, but my contents:
            return (T[]) Arrays.copyOf(elementData, size, a.getClass());		//指定新数组的类型.class
        System.arraycopy(elementData, 0, a, 0, size);
        if (a.length > size)
            a[size] = null;
        return a;
    }
```

## get add set remove

```java
    public E get(int index) {			//根据index 调用	rangeCheck方法安全性校验
        rangeCheck(index);

        return elementData(index);		//直接返回对应下标数据
    }

    public E set(int index, E element) {	//在指定索引set元素
        rangeCheck(index);			//安全性校验

        E oldValue = elementData(index);//取出旧值
        elementData[index] = element;	//放入新值
        return oldValue;//返回被替换的值
    }


    private void rangeCheck(int index) {		//根据索引判断是否下标越界
        if (index >= size)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }
```

## add

```java
	public boolean add(E e) {		//添加一个元素 不指定下标
        ensureCapacityInternal(size + 1);  //校验数组大小初始化 与 是否扩容
        elementData[size++] = e;
        return true;
    }


    public void add(int index, E element) {		//添加一个元素  指定下标
        rangeCheckForAdd(index);	//index安全性校验

        ensureCapacityInternal(size + 1); //校验数组大小初始化 与 是否扩容
        //复制新数组, 赋值当前新数组中被插入数据的index之后的所有数据到index+1的位置(全部后移一位)
        //复制的个数为,index之后元素的数量, 复制到当前数组;  性能较差
        System.arraycopy(elementData, index, elementData, index + 1,	 
                         size - index);
        elementData[index] = element;// 移动完成后,当前index查出新元素
        size++;//size+1
    }
	//传入的index 安全性校验
    private void rangeCheckForAdd(int index) {
        if (index > size || index < 0)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }

```

## 初始化ensureCapacityInternal, 扩容grow

```java
	//确保容量所调用的一系列方法
 	private void ensureCapacityInternal(int minCapacity) {
        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
    }

 	private static int calculateCapacity(Object[] elementData, int minCapacity) {
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {	//数组是否为空
            //为空则指定默认值10 与 添加一个数之后的size中最大值, 此处定义了初始值为10 ,但是空数组是首次add时进行赋值
            return Math.max(DEFAULT_CAPACITY, minCapacity);
        }
        return minCapacity;
    }

	private void ensureExplicitCapacity(int minCapacity) {
        modCount++;//修改次数+1

        // overflow-conscious code
        if (minCapacity - elementData.length > 0)  //如果当前容量-length > 0 说明越界了 要扩容
            grow(minCapacity);
    }


	//扩容方法
	private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + (oldCapacity >> 1); //新值为 1.5倍 因为length+length>>1 = 1.5倍
        if (newCapacity - minCapacity < 0) //新值是否比当前添加之后的最新值大, 大的话新数组大小为 1.5倍
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE > 0)//如果新数组最大值,大于MAX_ARRAY_SIZE
            newCapacity = hugeCapacity(minCapacity);	//调用方法校验minCapacity确认新的值大小
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);// copyOf新数组;
    }

	//校验调用方法校验minCapacity
    private static int hugeCapacity(int minCapacity) {
        if (minCapacity < 0) // overflow	//小于0  
            throw new OutOfMemoryError();	// 内存溢出报错,此时说明值已经超出存储界限了
        return (minCapacity > MAX_ARRAY_SIZE) ?	// 如果minCapacity > 数组MAX_ARRAY_SIZE最大值
            Integer.MAX_VALUE :	//赋值为Integer最大值,否则为数组最大值
            MAX_ARRAY_SIZE;
    }
```

## remove

```java
    public E remove(int index) { //删除指定下标的元素
        rangeCheck(index);  //下标安全性校验, 跑出下标越界异常

        modCount++;
        E oldValue = elementData(index);	//被删除的值

        int numMoved = size - index - 1;	//赋值新数组做准备, 计算出需要被移动的数据个数
        if (numMoved > 0)
            //复制到当前数组, 其实位置index+1, 新位置index , 个数为numMoved
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        //数组最后一个位置置为null ,方便GC回收垃圾
        elementData[--size] = null; // clear to let GC do its work

        return oldValue;//返回被删除的值
    }

	//删除指定元素
    public boolean remove(Object o) {
        //是否为null的情况
        if (o == null) {
            //遍历查询,删除第一个,就会返回删除成功
            for (int index = 0; index < size; index++)
                if (elementData[index] == null) {
                    fastRemove(index);
                    return true;
                }
        } else {
            //遍历查询,删除第一个,就会返回删除成功
            for (int index = 0; index < size; index++)
                if (o.equals(elementData[index])) {
                    fastRemove(index);
                    return true;
                }
        }
        //没有相同元素, 返回false
        return false;
    }
```

## clear

```java
    public void clear() {
        modCount++;

        // clear to let GC do its work
        for (int i = 0; i < size; i++)	//遍历置为null
            elementData[i] = null;

        size = 0;	//size归零
    }
```

## SubList与subList()

```java
 //此方法通过指定开始 结束索引 截取一段为一个新的List
//但是其返回值,并不是一个ArrayList 而是内部类 SubList,
public List<E> subList(int fromIndex, int toIndex) {
        subListRangeCheck(fromIndex, toIndex, size);
        return new SubList(this, 0, fromIndex, toIndex);
    }

//ArraysList.SubList,继承至AbstractList   AbstractList实现了List接口
 private class SubList, extends AbstractList<E> implements RandomAccess {
     	//此处修饰的集合  是一个final的 不可变
        private final AbstractList<E> parent;
        private final int parentOffset;
        private final int offset;
        int size;

        SubList(AbstractList<E> parent,
                int offset, int fromIndex, int toIndex) {
            this.parent = parent;
            this.parentOffset = fromIndex;
            this.offset = offset + fromIndex;
            this.size = toIndex - fromIndex;
            this.modCount = ArrayList.this.modCount;
        }

        public E set(int index, E e) {
            rangeCheck(index);
            checkForComodification();
            E oldValue = ArrayList.this.elementData(offset + index);
            ArrayList.this.elementData[offset + index] = e;
            return oldValue;
        }

        public E get(int index) {
            rangeCheck(index);
            checkForComodification();
            return ArrayList.this.elementData(offset + index);
        }

        public int size() {
            checkForComodification();
            return this.size;
        }

        public void add(int index, E e) {
            rangeCheckForAdd(index);
            checkForComodification();
            parent.add(parentOffset + index, e);
            this.modCount = parent.modCount;
            this.size++;
        }

        public E remove(int index) {
            rangeCheck(index);
            checkForComodification();
            E result = parent.remove(parentOffset + index);
            this.modCount = parent.modCount;
            this.size--;
            return result;
        }

        protected void removeRange(int fromIndex, int toIndex) {
            checkForComodification();
            parent.removeRange(parentOffset + fromIndex,
                               parentOffset + toIndex);
            this.modCount = parent.modCount;
            this.size -= toIndex - fromIndex;
        }

        public boolean addAll(Collection<? extends E> c) {
            return addAll(this.size, c);
        }

        public boolean addAll(int index, Collection<? extends E> c) {
            rangeCheckForAdd(index);
            int cSize = c.size();
            if (cSize==0)
                return false;

            checkForComodification();
            parent.addAll(parentOffset + index, c);
            this.modCount = parent.modCount;
            this.size += cSize;
            return true;
        }
```



## 其他

```java
   	//根据集合批量添加
	public boolean addAll(Collection<? extends E> c) {
        Object[] a = c.toArray();
        int numNew = a.length;
        ensureCapacityInternal(size + numNew);  // Increments modCount
        System.arraycopy(a, 0, elementData, size, numNew);
        size += numNew;
        return numNew != 0;
    }

	//在指定索引开始批量添加
    public boolean addAll(int index, Collection<? extends E> c) {
        rangeCheckForAdd(index);

        Object[] a = c.toArray();
        int numNew = a.length;
        ensureCapacityInternal(size + numNew);  // Increments modCount

        int numMoved = size - index;
        if (numMoved > 0)
            System.arraycopy(elementData, index, elementData, index + numNew,
                             numMoved);

        System.arraycopy(a, 0, elementData, index, numNew);
        size += numNew;
        return numNew != 0;
    }

	//删除指定index的区间
    protected void removeRange(int fromIndex, int toIndex) {
        modCount++;
        int numMoved = size - toIndex;
        // 不删除toIndex索引上的元素
        System.arraycopy(elementData, toIndex, elementData, fromIndex,
                         numMoved);

        // clear to let GC do its work
        int newSize = size - (toIndex-fromIndex);
        for (int i = newSize; i < size; i++) {
            elementData[i] = null;
        }
        size = newSize;
    }
	//index校验
     private void rangeCheck(int index) {
        if (index >= size)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }

	//index校验
    private void rangeCheckForAdd(int index) {
        if (index > size || index < 0)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }

	//根据集合删除 调用批处理方法
    public boolean removeAll(Collection<?> c) {
        Objects.requireNonNull(c);
        return batchRemove(c, false);
    }

	//删除元素的批处理
    private boolean batchRemove(Collection<?> c, boolean complement) {
        final Object[] elementData = this.elementData;
        int r = 0, w = 0;
        boolean modified = false;
        try {
            for (; r < size; r++)
                if (c.contains(elementData[r]) == complement)
                    elementData[w++] = elementData[r];
        } finally {
            // Preserve behavioral compatibility with AbstractCollection,
            // even if c.contains() throws.
            if (r != size) {
                System.arraycopy(elementData, r,
                                 elementData, w,
                                 size - r);
                w += size - r;
            }
            if (w != size) {
                // clear to let GC do its work
                for (int i = w; i < size; i++)
                    elementData[i] = null;
                modCount += size - w;
                size = w;
                modified = true;
            }
        }
        return modified;
    }

```

# LinkedList

## 构造方法与属性

```java
	//双向链表 

	//初始大小
	transient int size = 0;

    /**
     * Pointer to first node.
     * Invariant: (first == null && last == null) ||
     *            (first.prev == null && first.item != null)
     */
	//第一个节点
    transient Node<E> first;

    /**
     * Pointer to last node.
     * Invariant: (first == null && last == null) ||
     *            (last.next == null && last.item != null)
     */
	//最后一个节点
    transient Node<E> last;

	//静态内部类, Node节点, 包含 上一个节点 下一个节点 和当前节点的信息
	private static class Node<E> {
        E item;//当前节点
        Node<E> next; //下一个节点
        Node<E> prev; // 上一个节点

        Node(Node<E> prev, E element, Node<E> next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }
```

```java
	public LinkedList() {
    }

    /**
     * 调用addAll方法完成添加
     */
    public LinkedList(Collection<? extends E> c) {
        this();
        addAll(c);
    }
```



## getFirst  getlast

```java
    public E getFirst() {
        //返回成员属性存储的头结点
        final Node<E> f = first;
        if (f == null)
            throw new NoSuchElementException();
        return f.item;
    }


    public E getLast() {
        //返回成员属性存储的最后一个节点
        final Node<E> l = last;
        if (l == null)
            throw new NoSuchElementException();
        return l.item;
    }
```

## removeFirsst / last

```java
    //删除头元素
	public E removeFirst() {
        final Node<E> f = first;
        if (f == null)
            throw new NoSuchElementException();
        //调用实际进行删除的方法
        return unlinkFirst(f);
    }

	//实际进行删除的方法
    private E unlinkFirst(Node<E> f) {
        // assert f == first && f != null;
        //定义当前元素 与nex元素
        final E element = f.item;
        final Node<E> next = f.next;
        //原数据置空
        f.item = null;
        f.next = null; // help GC
        // 头结点置为next
        first = next;
        //如果没有下一个节点(链表长度1) last节点置null
        if (next == null)
            last = null;
        else
            //否则 next的上一个节点为null
            next.prev = null;
        size--;
        modCount++;
        //删除被移除的节点
        return element;
    }

	//删除尾元素
    public E removeLast() {
        final Node<E> l = last;
        if (l == null)
            throw new NoSuchElementException();
        return unlinkLast(l);
    }
	//实际删除方法
    private E unlinkLast(Node<E> l) {
        // assert l == last && l != null;
        //定义变量
        final E element = l.item;
        final Node<E> prev = l.prev;
        //置为null
        l.item = null;
        l.prev = null; // help GC
        last = prev;
        //如果没有上一个节点(链表只有一个元素,则头节点置空)
        if (prev == null)
            first = null;
        else
            //否则尾节点的上一个节点.next=null
            prev.next = null;
        size--;
        modCount++;
        //返回被移除元素
        return element;
    }


```

## add

```java
    public boolean add(E e) {
        //调用方法从尾部添加
        linkLast(e);
        return true;
    }

    //添加方法
    void linkLast(E e) {
        //从last节点插入
        final Node<E> l = last;
        //创建new节点
        final Node<E> newNode = new Node<>(l, e, null);
        last = newNode;
        //last为null说明链表为空,数据存储到first
        if (l == null)
            first = newNode;
        else
            //否则new关联到last.next
            l.next = newNode;
        size++;
        modCount++;
    }
```

## remove

```java
    //删除指定元素
	public boolean remove(Object o) {
       	//从头结点开始遍历,null值, 找到对应的null删除返回true
        if (o == null) {
            for (Node<E> x = first; x != null; x = x.next) {
                if (x.item == null) {
                    unlink(x);
                    return true;
                }
            }
        } else {
            //不为null  遍历链表,equals对比 相同则调用unlink删除
            for (Node<E> x = first; x != null; x = x.next) {
                if (o.equals(x.item)) {
                    unlink(x);
                    return true;
                }
            }
        }
        //没有相同的则返回false
        return false;
    }


```

## get

```java
    //获取指定索引上的数据
	public E get(int index) {
        checkElementIndex(index); //校验索引是否大于size
        return node(index).item;//调用方法
    }
```

## set

```java
    //在指定索引上更新值
	public E set(int index, E element) {
        checkElementIndex(index);//索引校验
        //获取指定索引上的值
        Node<E> x = node(index);
        //取出当前元素
        E oldVal = x.item;
        //将当前元素赋值为新的值
        x.item = element;
        //返回被替换的值
        return oldVal;
    }

```

## remove

```java
   public E remove(int index) {
        checkElementIndex(index);//index校验
        return unlink(node(index));//获取当前索引的索引传入删除方法
    }
```

## unlink

```java
	//删除元素的方法
	 E unlink(Node<E> x) {
        // assert x != null;
         //需要被删除的元素,已排除null
        final E element = x.item;
         //取出被删除节点的 prev 与 next
        final Node<E> next = x.next;
        final Node<E> prev = x.prev;
         
		//判断头和尾是否为null的情况
         //头为null,将first节点替换为next
        if (prev == null) {
            first = next;
        } else {
            //否则用当前元素的prve.next关联当前元素的next, 
            prev.next = next;
            //并将当前元素的prve置位null
            x.prev = null;
        }
		//尾节点为null
        if (next == null) {
            //last = prve
            last = prev;
        } else {
            //否则当前元素的next元素prve节点关联为被删除元素的prve 
            next.prev = prev;
            //并把当前元素的next置位null
            x.next = null;
        }
		//修改完成
        x.item = null;
        size--;
        modCount++;
        return element;
    }
```

## node

```java
	//根据索引获取
    Node<E> node(int index) {
        // assert isElementIndex(index);
		//当前索引 大于?小于 size>>1  中间值 应该从first还是last开始遍历
        if (index < (size >> 1)) {
            //从头开始遍历
            Node<E> x = first;
            //遍历到index索引位置 此处索引不同于数组索引 传入的索引不减1
            for (int i = 0; i < index; i++)
                x = x.next;
            //返回遍历到的最后一个数据
            return x;
        } else {
            //从尾部开始遍历
            Node<E> x = last;
            for (int i = size - 1; i > index; i--)
                x = x.prev;
            return x;
        }
    }
```

## 队列相关

## peek

```java
    public E peek() {
        final Node<E> f = first;
        return (f == null) ? null : f.item;//获取头结点元素
    }
```

## poll

```java
    public E poll() {
        final Node<E> f = first;
        return (f == null) ? null : unlinkFirst(f); //返回并删除头节点 从头结点弹出
    }
```

## offer

```java
   public boolean offer(E e) {
        return add(e); //从尾部添加一个元素
    }
    public boolean offerFirst(E e) {
        addFirst(e); 	//从头部添加一个元素
        return true;
    }

    public boolean offerLast(E e) {
        addLast(e);		//从尾部添加一个元素
        return true;
    }
```

