# 数据结构

## 简单动态字符串

> Redis使用SDS表示字符串值,C字符串只会作为字符串的字面量用在一些无需对字符串值修改的地方.

- 用于保存字符串值
- 用于缓冲区AOF模块缓冲区,以及客户端状态中的输入缓冲区

### 结构定义

![image-20210814002854822](https://jianjiandawang.oss-cn-shanghai.aliyuncs.com/Typora/20210814002854.png)

```c
struct sdshdr{
    //记录buf数组中已使用的字节的数量,等于SDS所保存的字符串的长度
    int len;
    //记录bug数组中未使用字节的数量
    int free;
    //字节数组,用于保存字符串
    char buf[];
}
```

> SDS遵循C字符串以空字符结尾的惯例(兼容使用C的函数库),保存的空字符串不计入在len中.
>
> SDS的数组保存的是二进制字节,而不是保存字符.

### 空间分配策略

字符串需要修改时,API会先检查free是否满足修改需求

- 不满足: 自动将SDS空间扩展到执行修改所需要的大小,然后执行修改
- 满足: 执行修改

### 惰性空间释放

一般程序修改字符串长度的情况不常出现,修改后通常执行一次内存修改.redis频繁修改的场合并不合适.

- SDS通过未使用空间(free)解除了字符串长度和底层数组长度之间的关联.buf数组的长度不一定是数组长度+1,而是len+free+1;数组里包含未使用的字节,由free记录.

> redis使用free实现惰性空间释放减少内存重新分配的次数

> ps: 通过惰性空间释放策略,SDS避免了缩短是内存冲分配,并未将来的增长操作提供优化

### 空间预分配

> 空间预分配用于优化SDS的字符串增长操作

当程序对SDS空间进行扩展时,程序不仅会分配必须要的空间,还会分配额外的空间.

- 修改之后len<1MB 分配len属性同样大小的空间, 此时len的长度将会和free相等
- 修改之后len>1MB 分配额外1MB空间, 此时free长度为1MB

> 通过空间预分配策略,Redis可以连续减少执行字符串增长操作所需要的内存重新分配次数

> ps: 通过内存重分配策略,将SDS内存重分配次数从N次降低到了最多N次

### 二进制安全

> ***redis字符串是二进制安全的*** 因为redis使用len判断字符串结尾而不是通过空字符换判断

所有SDS的API都会以处理二进制的方式处理SDS存在buf中的数据,程序不会对其做任何修改.

### 总结

- C字符串仅做字面量
- **使用SDS作为字符串表示**
- **常数复杂度获取字符串长度len**
- 杜绝缓冲区溢出
- **减少修改字符串的内存重新分配次数**
- **二进制安全**
- 兼容C字符串函数

## 链表

> 列表(List)的底层实现之一
>
> 发布与订阅/慢查询/监视器/客户端状态信息也使用到链表

当列表键包含数量比较多的元素,或者列表中包含的元素都是比较长的字符串时,Redis使用链表作为列表的底层实现.

### 链表和链表节点实现

```c
typedef struct listNode{
    //上一个节点
    struct listNode *prev;
    //下一个节点
    struct listNode *next;
    //节点的值
    void *value;  
}
```

> listNode通过 prev 与 next指针组成双端列表.

```c
typedef struct list{
    
    //表头节点
    listNode *head;
    //表尾节点
    listNode *tail;
    //链表所包含的节点数量
    unsigned long len;
    //节点值复值函数,用于复制链表节点所保存的值
    void *(*dup) (void *ptr);
    //节点值释放函数,用于释放链表节点上所保存的值
    void *(*free) (void *ptr);
    //节点值对比函数,用于对比链表节点的值与另一个输入值是否相等
    int (*match) (void *ptr,void *key);
} list;
```

### 特性

- 双端,获取前置与后置节点的时间复杂度O(1)
- 无环,头prev尾next为null; 以null作为终点
- 带表头与表尾指针
- 带链表长度计数器. 获取长度时间复杂度O(1)
- 多态,可以保存各种不同类型的值

## 字典

> 又称符号表/Map.一种用于保存键值对的抽象数据结构.
>
> 字典的底层使用哈希表作为实现.
>
> 字典是hash的底层存储结构之一.

- 每个键独一无二
- 每个值关联一个键

> Redis的数据库就是使用字典实现的.对数据库的CRUD是构建在字典的操作之上

### 哈希表

```c
typedef struct dictht{
    //哈希表数组,
    dictEntiy **table;
    //哈希表的大小
    unsigned long size;
    //哈希表的大小掩码,用于计算索引值
    //总是等于size-1,这个属性决定key放到哪个索引上.  hash && size-1
    unsigned long sizemask;
    //该哈希表已有节点的数量
    unsigned long used;
}dictht;
```

### 哈希表节点

```c
typedef struct dictEntry{
    //键
    void *key;
    //值
    union {
        void *val;
        unit64_t u64;
        int64_t s64;
    }v;
    
    //指向下一个哈希表节点  形成链表
    struct dictEntry *next;
}dictEntry;
```

- key保存键值对中的键,而v属性保存着键值对的值,其中的值可以是一个指针或者uint_64/int_64证书
- next属性是指向另一个哈希表的节点指针,可以将多个哈希值相同的键值对连接在一起.以此来解决哈希冲突的问题





























